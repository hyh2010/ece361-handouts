\documentclass[11pt]{article}

\usepackage{../style/ece361}

%-------------------------------------------------------------------------------------------------

% Lab parameters
\def\thelab{2}
\def\datedue{Feb. 7, 2020 @ 3 PM}

\useCompactTitle{ECE361 Lab \thelab}{ARQ Protocols}

%-------------------------------------------------------------------------------------------------
\begin{document}
% Create title page, and force header and footer onto it
\maketitle \thispagestyle{fancy}
\hfill {\large \textbf{Due \datedue}}
%-------------------------------------------------------------------------------------------------


%-------------------------------------------------------------------------------------------------
\section{Overview}
\label{sec:overview}
%-------------------------------------------------------------------------------------------------
In many applications reliable data transmission over an unreliable service is required. ARQ protocols are for exactly that. In this lab, you will be given 2 virtual hosts and an unreliable channel between them. With that you will first enhance the Stop and Wait protocol implemented in lab 1 to work on an unreliable channel. After that you will implement a better, more efficient sliding window protocol.

%-------------------------------------------------------------------------------------------------
\section{Preparation}
\label{sec:preparation}
%-------------------------------------------------------------------------------------------------
\subsection{Network Namespaces}
Network namespaces virtualize the network stack. Each network namespace contains its own interfaces, routing tables and iptables rules. The script for setting up 2 network namespaces and a communication channel between them is provided to you. Run the following command:
\begin{lstlisting}[language=bash]
$ sudo sh setup_scripts/lab2_setup.sh
\end{lstlisting}
Open 2 terminals and run the following commands:
On terminal 1:
\begin{lstlisting}[language=bash]
$ sudo ip netns exec h1 bash
\end{lstlisting}
On terminal 2:
\begin{lstlisting}[language=bash]
$ sudo ip netns exec h2 bash
\end{lstlisting}
You might have guessed it, 2 namespaces, h1 and h2 are created and we opened a bash shell within each namespace. Now, we can find out about each namespace using the utility commands introduced in lab 1. For example, in terminal 1, run:
\begin{lstlisting}[language=bash]
$ ip addr
\end{lstlisting}
The output will look something like this:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Output of 'ip addr'}, language=bash]
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
3: veth1@if4: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 96:9d:be:75:82:4e brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 192.168.1.1/24 scope global veth1
       valid_lft forever preferred_lft forever
    inet6 fe80::949d:beff:fe75:824e/64 scope link 
       valid_lft forever preferred_lft forever
\end{lstlisting}
\end{minipage}
The first entry is the loopback interface which is created by default when the namespace gets created. The second entry veth1 is the most important. It is created for communication between h1 and h2. As you can see, in the h1 interface the ip address associated with veth1 is 192.168.1.1. Similarly, the ip address for h2 is 192.168.1.2.
\subsection{Test Communication between Virtual Hosts}
On the h1 terminal, run:
\begin{lstlisting}[language=bash]
$ ping 192.168.1.2
\end{lstlisting}
If everything works correctly, the ping should work. Similarly, the ping from h2 to h1 should also work.
\subsection{Adding Packet Drop}
We need an unreliable channel so we can implement ARQ on top of that. The tool for doing that is called tc.
Run the following command in another terminal outside of the namespaces:
\begin{lstlisting}[language=bash]
$ sudo tc qdisc add dev veth0 root netem loss 10%
\end{lstlisting}
You can find out more about the tc tool by running the 'man tc' command.
The 'ping' command can be used to test packet loss as well. However, there is a tool called iperf3 which is better suited for this purpose. From the h1 terminal, run:
\begin{lstlisting}[language=bash]
$ iperf3 -s
\end{lstlisting}
From the h2 terminal, run:
\begin{lstlisting}[language=bash]
$ iperf3 -c 192.168.1.1 -u -t 10
\end{lstlisting}
Wait until the test finishes, and take note of the last few lines of output:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Output of 'iperf3'}, language=bash]
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams
[  4]   0.00-10.00  sec  1.24 MBytes  1.04 Mbits/sec  0.033 ms  18/159 (11%)  
[  4] Sent 159 datagrams
\end{lstlisting}
\end{minipage}

\noindent For the Lost/Total Datagrams column you should be getting around 10\%. Actual results may vary from run to run.

\noindent Notice that if you run the iperf3 test in the other direction from h1 to h2, there is no packet loss. This is because we have only enabled packet loss in a single direction. To enable packet loss from h1 to h2, run the following command:
\begin{lstlisting}[language=bash]
$ sudo tc qdisc add dev veth2 root netem loss 10%
\end{lstlisting}

Now run the iperf3 test again, and you should see packet loss for both directions.
%-------------------------------------------------------------------------------------------------
\subsection{Activate the Virtual Environment}
Activate the virtual environment.
\begin{lstlisting}[language=bash]
$ source venv/bin/activate
\end{lstlisting}
You need to run the above command in both terminals containing the h1 and h2 namespaces.

On terminal 1:
\begin{lstlisting}[language=bash]
$ sudo ip netns exec h1 bash
$ source venv/bin/activate
\end{lstlisting}
On terminal 2:
\begin{lstlisting}[language=bash]
$ sudo ip netns exec h2 bash
$ source venv/bin/activate
\end{lstlisting}
Once the virtual environment is created the command 'python' can be used in place of 'python3'. Verify that the virtual environment is created with the correct python version. Make sure it is python 3.x not python 2.x. For example, within the virtual environment, run:
\begin{lstlisting}[language=bash]
$ python --version
Python 3.5.2
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsection{Design Overview}
In the last lab, you were asked to manually split a large file into smaller segments and send each individual segment by calling some socket API. In this lab, we have abstracted some of the low level details so you can use a set of higher level APIs that are easier to work with.
\figvs{0.8}{sender_class}{trim=0cm 0cm 0cm 0cm,clip}{Sender Class}
\figvs{0.8}{frame_class}{trim=0cm 0cm 0cm 0cm,clip}{Frame Class}

\subsection{Stop and Wait}
\subsubsection{Config File}


\subsubsection{Simple Stop and Wait}
We have implemented a stop and wait protocol similar to that of lab 1 that will work on an errorless channel. First set the following configuration:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Configuration For Small File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
\end{minipage}

In this part we assume an errorless channel. Remove packet drop:
\begin{lstlisting}[language=bash]
$ sudo tc qdisc change dev veth0 root netem loss 0%
$ sudo tc qdisc change dev veth2 root netem loss 0%
\end{lstlisting}
Now run the following:

From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py received.txt
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py text_file_small.txt
\end{lstlisting}
Since the receiver is just a server that always listens to incoming packets, it does not know when the transmission ends. Therefore, you need to Ctrl-C the receiver before proceeding. This applies to all sections of the lab.
The sender should finish (If the sender doesn't exit by itself, Ctrl-C it). Verify that the file gets transmitted successfully:
\begin{lstlisting}[language=bash]
$ cat received.txt
I only have a few bytes.
\end{lstlisting}

\subsubsection {The --debug option}
We have provided you with a feature that prints out the progress on the sender and receiver frame by frame. This is very useful for later on for either debugging your code or just to understand how the protocol works. Try the following:

From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py --debug received.txt
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py --debug text_file_small.txt
\end{lstlisting}

Try understanding the debug message. It shouldn't be too hard since this is just a simple stop and wait and you implemented the same algorithm in lab 1. However, later on when the algorithm gets more complicated this will become more useful.

\subsection{Round Trip Time}
Now let's try a larger file. For larger files we need to increase the frame-size so the transmission doesn't take forever. Let's change the frame-size to 1024 (or 1K bytes):
\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
Run the following:

From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py received
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py binary_file_large
\end{lstlisting}

\warn{Do not use the '--debug' option when sending large files! The debug messages will flood your screen.}

Verify that the file get transmitted successfully, this time with a diff:
\begin{lstlisting}[language=bash]
$ diff binary_file_large received
\end{lstlisting}

Note that when the transmission ends the sender prints out some statistics:

\begin{lstlisting}[language=bash]
ARQ protocol: stopandwait
frames sent: 9106
frames delivered: 9106
transmission time: 0:00:03.292909
average rtt: 0:00:00
maximum rtt: 0:00:00
\end{lstlisting}

We have implemented the 'frames sent', 'frames delivered' and 'transmission time' statistics for you. We have left the rtt statistics for you to implement. Complete the class function \_update\_rtt in stopwaitsender.py, assuming a new frame just gets delivered with t\_send and t\_ack. You need to first calculated a new rtt sample based on t\_send and t\_ack and then update the rtt\_max and rtt\_total member variables. The rest of the calculations (e.g. average) has already been implemented for you. After you are done, rerun the previous binary\_file\_large experiment and make sure you get the rtt statistics printed out.

\subsection{Handling Frame Drop}
After you get the basic stop and wait working, enable frame drop from h2 to h1. Keep the channel from h1 to h2 errorless for now. For example, set the frame drop rate to 5\%:
\begin{lstlisting}[language=bash]
sudo tc qdisc change dev veth0 root netem loss 5%
\end{lstlisting}
Let's change the frame-size back to 1 for now:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": null,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
\end{minipage}
Rerun the 'text\_file\_small.txt with the '--debug' option. What is the result and why?
\subsubsection {Choosing a timeout}
In the previous experiment you saw that the prgram hang because if a frame is lost the sender would be waiting for the acknowledgement forever. To fix this, we need an appropriate timeout such that when the timer expires the sender retransmits the previous frame. Base on your rtt calculation in the previous section, change the "timeout" field of the config file from "null" to an appropriate value (Note: the unit is second, and floating point number is accepted)

\think{Should the timeout be based on the average or max rtt and why?}

\noindent Now rerun the 'text\_file\_small.txt' experiment and test if the transmission is successful.

\noindent After you get the small file working, change frame-size to 1024 and try transmitting binary\_file\_large.

\think{Can you figure a mathematical relationship between the expected frames sent, frames deliverd and the frame drop rate? Does the experimental result agree with your formula?}

\subsection {Handling Lost Ack}
Now let's enable frame lost from h1 to h2 as well.
\begin{lstlisting}[language=bash]
sudo tc qdisc change dev veth2 root netem loss 5%
\end{lstlisting}

Change the frame-size configuration back to 1:
\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": <your choice>,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 0
}
\end{lstlisting}
Now rerun the text\_file\_small.txt experiment and examine the result. You should see something like this:

\begin{lstlisting}[language=bash]
$ cat received.txt 
I only havee a few bytess.
\end{lstlisting}
The actual result varies from run to run, but the key here is duplicated frames. If you don't see duplicated frames then try again. If you still can't see it then you might want to increase the frame drop rate (e.g. from 5% to 10%).

To explain what happened, since the ack frame can be lost, the next frame the receiver received can either be a resend of the previous frame (due to lost ack) or a new frame (if ack successfully received by the sender). Without sequence numbers the receiver cannot distinguish betweeen these two cases. The sequence numbers are actually implemented already, you just need to enable it in the config. Set the "maxseqnum" field of the config file to any positive integer (e.g. 64).

\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": <your choice>,
    "frame_size": 1,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

Now rerun the 'text\_file\_small.txt' experiment and you should see that the file gets successfully transmitted (no more duplicated frames).

Finally, let's test the fully implemented stop and wait ARQ protocol on binary\_file\_large. Set the 'frame-size' back to 1024:

\begin{lstlisting}[caption={Configuration For Large File}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "stopandwait",
    "timeout": <your choice>,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}
From the h1 terminal:
\begin{lstlisting}[language=bash]
$ python receiver.py received
\end{lstlisting}
From the h2 terminal:
\begin{lstlisting}[language=bash]
$ python sender.py binary_file_large
\end{lstlisting}

\noindent You might need to wait for a while for the transmission to finish. Verify that the file gets transmitted successfully using diff.
\begin{lstlisting}[language=bash]
$ diff binary_file_large received
\end{lstlisting}

\noindent If the previous experiment succeeds, congratulations! You have a fully working stop and wait ARQ.

\section{Sliding Window ARQ}
From the previous section, you can see that although Stop and Wait protocol can achieve reliable transmission over an unreliable service, it can be quite inefficient sometimes, especially when there are many timedout frames. This is because in the stop and wait protocol, frames are sent one at a time and if the sender is blocked waiting for acknowledgement no frame is being sent and the channel bandwidth is not being utilized efficiently. To fix this issue, we can send multiple frames at a time. This is where sliding window ARQ comes in. For the purpose of this lab, we are only going to modify the sender to use a sliding window and keeping the receiver the same. In the real world, however, both the sender and the receiver can use a sliding window to increase efficiency.

\subsection{Change the Config File to Use Sliding Window ARQ}
Change the "arq\_protocol" field of the config file from "stopandwait" to "slidingwindow". Make sure "window-size" is an integer greater than 1. Make sure "maxseqnum" is at least "window-size". Keep other parameters (e.g. timeout) the same as previous section:

\begin{lstlisting}[caption={Sliding Window Configuration}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "slidingwindow",
    "timeout": <your choice>,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

\think{If you set the window-size to be 1, what does the Sliding Window ARQ become?}

\subsection {A Simplified Example}
Demo only for now. To be completed.

\subsection{The Nack Frame}
In the Stop and Wait protocol, since at most one frame can be outstanding at any given time, the receiver is guaranteed to receive the frames in order. However, in the sliding window ARQ, the receiver might be receiving out-of-order frames. When this happens, the receiver can either drop the frame, or better, sending back a Nack to indicate that this frame is out-of-order and needs to be retransmitted (remember we are not implementing sliding window on the receiver side so the reciever only has a buffer size of 1 so cannot accept out-of-order frames). The NACK approach is what we are going to use for this lab. The way the NACK works is that, when the receiver sends the response frame, it always contain a sequence number that is the sequence number of the next frame the receiver is expected to receive. When the sender receive the Ack/Nack, it needs to verify this number against the sequence number of the frame it just sent to see if it sent the right frame.

\noindent Now open the file 'slidingwindowsender.py' and find the '\_\_ack\_nack' function. Implement this function based on what you just learnt.

\subsection{Implement the Sliding Window ARQ}
Based on what you've done so far, take a look at the '\_arq\_send' function in 'slidingwindowsender.py'. We have started the implementation by creating a send\_queue for keeping track of the sliding window. Follow the guidelines to complete the implementation. Please also implement the "frames\_sent" and "frames\_delivered" statistics. During the debugging stage, it is recommended to test transmitting "text\_file\_small.txt" with "frame-size" 1 and "--debug" on. (However, the DEBUG messages on the sender side needs to be implemented by you). 


\noindent After you are confident that you have a working solution, test your implementation by sending the 'binary\_file\_large' file on a channel with 5\% loss both directions and "frame-size" 1024:
\begin{lstlisting}[caption={Sliding Window Configuration}]
{
    "sender_address": "192.168.1.2",
    "receiver_address": "192.168.1.1",
    "receiver_port": 6789,
    "arq_protocol": "slidingwindow",
    "timeout": <your choice>,
    "frame_size": 1024,
    "window_size": 2,
    "maxseqnum": 64
}
\end{lstlisting}

First set the window size to 2. Do you see an improved performance compared to Stop and Wait? If you keep increasing the window size, what do you see? Can you explain why?

\section{Cleanup}
After finishing the lab, please run:
\begin{lstlisting}[language=bash]
$ sudo sh setup_scripts/lab2_cleanup.sh
\end{lstlisting}

\section{TA Grading}
\label{sec:tagrading}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

%-------------------------------------------------------------------------------------------------
\section{Exerciser}
\label{sec:exercise}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

%-------------------------------------------------------------------------------------------------
\section{Submission}
\textbf{TODO}
Tell them to submit just 'stopandwaitsender.py' and 'slidingwindowsender.py'. During the lab they can change other files for experimenting purposes, but their final code have to work with the code we provide them.

Also tell them if they discover a bug in one of the files please report it (Piazza?)
\label{sec:submission}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

\end{document}
