\documentclass[11pt]{article}

\usepackage{../style/ece361}

%-------------------------------------------------------------------------------------------------

% Lab parameters
\def\thelab{1}
\def\datedue{Feb. 1, 2020 @ 11:59 PM}

\useCompactTitle{ECE361 Lab \thelab}{Message Transfer}

%-------------------------------------------------------------------------------------------------
\begin{document}
% Create title page, and force header and footer onto it
\maketitle \thispagestyle{fancy}

\hfill {\large \textbf{Due \datedue}}
%-------------------------------------------------------------------------------------------------


%-------------------------------------------------------------------------------------------------
\section{Overview}
\label{sec:overview}
%-------------------------------------------------------------------------------------------------
A network address is a logical (e.g., IP address) or physical address (e.g., MAC address) that uniquely distinguishes a network node from other nodes on the network. It is usually a number that is assigned to any device or network interface card that seeks access to be part of the network. A network node such as a personal computer or a mobile phone may also have several applications that use the node's connection to communicate with one another across the network. To distinguish the applications data from one another, the operating system allows applications to use port numbers. Therefore, each applications data will be mapped to a port number as consecutively they all can share the same network address to communicate on the network. By analogy, we can assume an apartment building that each unit has its own unit number, but they all share the same geographical address on the map. 

To use a port number, applications are required to use a socket. A socket is one endpoint of a two-way communication link which is bound to a port number so that the transport layer protocols can identify the application that the data is destined to. Throughout this lab, we first learn how to use a socket to transmit data across the network and then we use our knowledge to build a simple file transfer application. We also see how headers are used to carry the network addresses and enable the network to guide the data message to any destination nodes.

%-------------------------------------------------------------------------------------------------
\section{TA Grading}
\label{sec:tagrading}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

%-------------------------------------------------------------------------------------------------
\section{Exerciser}
\label{sec:exercise}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

%-------------------------------------------------------------------------------------------------
\section{Submission}
\label{sec:submission}
%-------------------------------------------------------------------------------------------------
\textbf{TODO}

\newpage
%-------------------------------------------------------------------------------------------------
\section{Appendix A: The \texttt{ece361} Python Library}
\label{sec:appendix-ece361-lib}
%-------------------------------------------------------------------------------------------------
The \texttt{ece361} library includes a networking package which implements an enhanced environment that allows the developers (students) to experiment various forms of end to end communications using network addresses. While the networking package offers the same programming features that you normally need to work with in real production, it offers more flexibility for to supporting the objectives followed by the course. As a result, you may need to seek for more information on network programming after you completed this lab assignment. 

The networking package offered by \texttt{ece361} library provides an important class called \texttt{Socket} which you will learn how to use its method to create network applications in both track 1 and track 2 of this lab assignments. The following section will explain the \texttt{Socket} class and its functions in more details.

%-------------------------------------------------------------------------------------------------
\subsection{The \texttt{Socket} Class}
\label{subsec:socket-class}
%-------------------------------------------------------------------------------------------------
A network socket is one endpoint of a two-way communication link. The endpoint can be created by a software application through a programming language library that provides the required features. Therefore, to enable an application to communicate over the network, the application developer must create a socket to build an endpoint. The endpoint can be used to send and receive data from the network. In this lab environment, you can easily build a socket by importing \texttt{ece361} networking package and create an object of the class \texttt{Socket}. The following demonstrate an example of how you can achieve this. In addition, you can find informative examples by completing the track 1 tutorial modules.

\begin{lstlisting}[caption={Importing the \texttt{Socket} class}, language=Python]
from ece361.netowrk.socket import Socket

# In your code
socket_object_name = Socket(<Your Student Number>)
\end{lstlisting}

The class socket in the lab1 environment requires you to provide your student number. This is because of the fact that the lab environment will create a personal and customized network for you which makes your data messages and experiments invisible to others. Therefore, it is of utmost importance to provide your student number correctly. Member of a team are required to use one of the team members student ID.

\textbf{Note:}
If you use a student number to create a socket object, you must use it on every single instance of your objects to allow the endpoints to be part of the same network. For instance, if you have a sender and a receiver application that need to exchange data with each other, you need to create an instance of the socket object on both and provide the same student number as an input on both socket objects. This way, they belong to the same network. You can also see examples of this by completing the track 1 modules.

After creating a socket object, the object allows you to use the following methods to build your applications. Please read each method's manual to learn more about the function they provide to you.

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{change\_source\_address(address, port)}}}
%-------------------------------------------------------------------------------------------------
This method allows you to change the socket address and port number. The format of the input arguments is:
\begin{itemize}
    \item \texttt{address}: An IP address or any name in the format of string characters.
    \item \texttt{port}: A number or name in the format of string characters.
\end{itemize}

\begin{lstlisting}[caption={Example for using \texttt{change\_source\_address()}}, language=Python]
my_socket = Socket('1234567890')
my_socket.change_source_address(address='130.14.45.88', port='1221')
...
my_socket.change_source_address(address='ece361', port='app1')
\end{lstlisting}

\textbf{Note:}
Be advised that in the enhanced environment provided by the \texttt{ece361} library, when you create a socket object, it chooses a random address and port number as the source address. The initial port number is â€˜N/A' which indicates the socket does not use any port number. Therefore, the following items are important to keep in mind.
\begin{itemize}
    \item If you created a socket, the best practice is to change the address and port numbers value to your preferred choices to avoid confusion. 
    \item Both address and port numbers must be provided in the string characters format. Please see the examples.
    \item The flexibility that you have to use a socket without specifying a port number is due to the environment characteristics that you work on. In real production environment, you must specify both the address and port numbers at the time of socket creation.
\end{itemize}

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{sendto(application\_data, dst\_address, dst\_port)}}}
%-------------------------------------------------------------------------------------------------
This method enables the application developers (students) to send data messages destination endpoints. The type of the input parameters are as follows:
\begin{itemize}
    \item \textbf{application\_data}: This parameter accepts string characters arguments.
    \item \textbf{dst\_address}: An IP address or any name in the format of string characters.
    \item \textbf{dst\_port}: A number or name in the format of string characters.
\end{itemize}

\textbf{Note:}
The \texttt{sendto()} function can carry application data which is less than or equal 100 bytes. It also return -1 if the data is larger than the maximum segment size or returns the length of the data that was successfully transmitted.

The \texttt{sendto()} method can be used in three ways.
\begin{enumerate}
    \item Without specifying a destination address and port number: This way the \texttt{sendto()} method broadcasts its data to every node on the network.
        \begin{lstlisting}[caption={}, language=Python]
my_socket.sendto(application_data)
        \end{lstlisting}

    \item Using a destination address without a port number: This approach can be used to send the data to a specific node on the network. However, if the name will be shared by several application receivers, they all will receive the message.
        \begin{lstlisting}[caption={}, language=Python]
my_socket.sendto(application_data='hi', dst_address='130.45.36.78')
        \end{lstlisting}

    \item Using both destination address and port number: This approach can be used to send the data to a specific application endpoint.
        \begin{lstlisting}[caption={}, language=Python]
my_socket.sendto(application_data='hi', dst_address='130.45.36.78', dst_port='app1')
        \end{lstlisting}
\end{enumerate}

\textbf{Note:}
To allow the receiver endpoint to receive the data message, the destination address and port numbers must match those of the receiver socket object. Therefore, you must first change the receiver source address and port number to any values of your choice before you send the data to the receiver. The new values can be used as the destination address on the \texttt{sendto()} method. Please complete the track 1 modules to see various examples of how to use your knowledge about the \texttt{sendto()} method in building your own applications.

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{recvfrom()}}}
%-------------------------------------------------------------------------------------------------
This method can be used to obtain the data messages from the network. The \texttt{recvfrom()} method does not require any input argument. If the method is used, it only receives the broadcast messages or the messages that are destined to this receiver. 

\textbf{Note:}
The receiver endpoint is identifiable in the network it's the source address and port numbers. Therefore, if a message is sent to a receiver by only specifying the destination address, the receiver can obtain the message if the destination address matches the one on the receiver. The receiver will also check the port number only if it is provided as a part of the destination address on the \texttt{sendto()} method. Please complete the track 1 modules to see various examples of how \texttt{recvfrom()} method can be used to build your own applications.

\textbf{Note:} 
The \texttt{recvfrom()} method will return the source (sender) address of the message as well as the message data. The address will be returned as a list where the first element is the sender's address and the second element is the sender's port number. Please note that if you send a broadcast message or a message without a destination port number, you may still receive the source address and port number. These values are either the sender's initial address and port number that are chosen at the time of the socket creation or are the values that have been set by the sender's application developer. In any case, you can use this information to get back to the sender, if necessary. Track 1 modules will show you how you can take the advantage of these information in building your own applications.

\begin{lstlisting}[caption={Example for using \texttt{recvfrom()}}, language=Python]
a, b = my_socket.recvfrom()
print(a) # [source address, source port]
print(b) # Message Data
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{display\_last\_header()}}}
%-------------------------------------------------------------------------------------------------
This method can be used to show the last sent message's header. When you use the \texttt{sendto()} method to send a message, the \texttt{sendto()} will create two data structures.
\begin{enumerate}
    \item \textbf{Message Header}: The header contains four pieces of data and is used to allow the network to navigate the messages to their destinations. The header contains the \texttt{[source\_address, source\_port, destination\_address, destination\_port]}. Therefore, by using this method you can always see the header of the last transmitted message.
    \item \textbf{Segment}: The segment includes both the header and the application data. 
\end{enumerate}

\textbf{Note:}
This information in the header depends on the values of the source address and how the developer specify the destination receiver for the \texttt{sendto()} method. You can see an example of how to use this method by completing the track 1 module 4.

\begin{itemize}
    \item A message header
		% figvs takes 4 parameters (see the style sheet for source code)
		%   1) Image width (w.r.t. column)
		%   2) Image file name
		%   3) Other 'includegraphics' parameters
		%   4) Caption
		\figvs{0.9}{msg-header}{trim=0cm 0cm 0cm 0cm,clip}{A message header.}

    \item A message segment
		\figvs{0.7}{msg-segment}{trim=0cm 0cm 0cm 0cm,clip}{A message segment.}
\end{itemize}

\begin{lstlisting}[caption={Example for using \texttt{display\_last\_header()}}, language=Python]
my_socket.display_last_header()
\end{lstlisting}

%-------------------------------------------------------------------------------------------------
\subsubsection{\texttt{Socket.\textbf{display\_last\_segment()}}}
%-------------------------------------------------------------------------------------------------
The same as above, this method can be used to see the last segment content.

\textbf{Note:}
You can see an example of how to use this method by completing track 1 module 4.

\begin{lstlisting}[caption={Example for using \texttt{display\_last\_segment()}}, language=Python]
my_socket.display_last_segment()
\end{lstlisting}

\end{document}
